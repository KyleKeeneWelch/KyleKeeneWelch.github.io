<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE-edge">
    <meta property="og:title" content="Home">
    <meta property="og:locale" content="en_US">
    <meta name="description" content="Github pages portfolio website">
    <meta property="og:description" content="Github pages portfolio website">
    <link rel="canonical" href="https://kylekeenewelch.github.io/my-site/index/">
    <meta property="og:url" content="https://kylekeenewelch.github.io/my-site/index/">
    <meta property="og:site_name" content="Kyle Keene-Welch">
    <meta property="og:type" content="website">
    <title>Final Year Project: Front-End Client | Kyle Keene-Welch</title>
</head>

<body>
    <main class="main-container">
        <header>
            <a href="index.html"><img src=<%=require("../../assets/images/home/logo.png")%> alt="Logo" /></a>
            <nav>
                <a href="index.html">Home</a>
                <a href="about.html">About</a>
                <a href="portfolio.html">Portfolio</a>
                <a href="contact.html">Contact</a>
            </nav>
        </header>
        <br>
        <section>
            <div class="project-intro">
                <div>
                    <h1>Front-End Client</h1>
                    <p>Mar 14th, 2024</p>
                </div>
                <div class="project-featured-image">
                    <img src=<%=require("../../assets/images/projects/book-app-client/project-poster.png")%>
                    alt="Project Poster" />
                </div>
                <div class="project-tags">
                    <p class="project-tag">Web</p>
                    <p class="project-tag">React</p>
                    <p class="project-tag">NPM</p>
                    <p class="project-tag">Axios</p>
                    <p class="project-tag">Local Storage</p>
                    <p class="project-tag">JWT</p>
                    <p class="project-tag">Client-Side Routing</p>
                    <p class="project-tag">Async/Await</p>
                </div>
            </div>
        </section>
        <section>
            <h2>Summary</h2>
            <p>
                This project is one component part of a larger Scalable, Reusable, Microservices architecture. It was
                developed in my Final Year Thesis as experimentation for the enhanced user interaction and experience
                applied from using the architecture for a business workflow. The demonstrated application was a Book
                Ratings and Reviews site that used the Event Sourcing System to define events, projections, and apply
                functions relating to Book Recommendations.
            </p>
            <p>
                The component comprises of reusable modules known as <span>React Components</span>, a
                <span>requester</span>, <span>context</span>, <span>helpers</span>, <span>hooks</span>, and
                <span>styles</span>. It it served on the Front-End to the user and interacts with both the browser and
                Back-End API to receive quick responses from lightweight endpoints and to update the DOM and reflect the
                changes. Routing is done on the client-side from the use of <span>React Router</span> where components
                are rendered to the user based on the URL entered / directed to instead of HTML pages generated by a
                server.
                Modules include:
            </p>
            <ul>
                <li><strong>React Components</strong> - React Components are reusable and maintain their own state.
                    These are mounted onto the DOM and are removed within a single HTML page which means the user can
                    seamlessly interact with the application without a refresh, although this is catered for with
                    persistent login.</li>
                <li><strong>API</strong> - The API module contains an Axios file with defines instances of Axios
                    exported in variables for creating requests to public and protected routes. The default Axios
                    variable will send a request without utilizing interceptors to attach an access token. The
                    AxiosPrivate variable will use the same base URL and will intercept the request and response to
                    attach an access token and retry an operation.</li>
                <li><strong>Context</strong> - The context module contains an AuthProvider which returns JSX for passing
                    an auth context to children of the component. This allows the rest of the application to securely
                    access the authentication state and to provide targeted content to the user and test for the
                    validity of the user after interactions.</li>
                <li><strong>Helpers</strong> - The helpers module contains a date file with exported functions to
                    convert dates returned by the Back-End API into useful formats to be displayed to the user.</li>
                <li><strong>Hooks</strong> - Hooks provide an additional level of reusable functionality between
                    components such as using the auth context, enabling the interceptors, logging out of the
                    application, refreshing to retrive a new access token, and tracking window dimensions to provide a
                    more responsive interface.</li>
                <li><strong>Styles</strong> - The styles module provides CSS files for styling specific to each page in
                    the application. It also includes an index file for redundant styles.</li>
                <li><strong>Client-Side Routing</strong> - Contained in an App file, routes are used to specify the path
                    a user should take to render a specific element. Nesting routes as children of one another impacts
                    which components have access to what passed data. Some routes use parameters that are retreived
                    within components to specify what unique entity the component should request for and display when
                    visiting such a page.</li>
            </ul>
        </section>
        <section>
            <h2>Features</h2>
            <ul>
                <li><strong>Collects user data</strong> â€“ Businesses can easily collect user data from interactions made
                    with the front-end client from asynchronous calls to the back end api to process these events. As
                    back-end api endpoints are made to be lightweight and utilizing REST principles, accessing these in
                    the front-end should be quick and easy.
                </li>
                <li><strong>Provides a Consistent, dynamic interface</strong> - The design of the front-end client
                    utilizes techniques to enforce consistency and update content personalized to the needs of users.
                    Using React in the demonstration, for example, will reuse components and will update state to
                    reflect the changes made by users.</li>
                <li><strong>Feeds from projections</strong> - Combining the processes involved in writing events in the
                    write model and accessing projections on the current state, the front-end client can receive this
                    data presentation layer and can reflect its visual and data components to accommodate the change. As
                    a result, an application can better target users and other tracked business domains like, for
                    example, providing product recommendations for a logged in user.</li>
                <li><strong>Uses Client-side routing and modularity</strong> - Using a client-side approach for routing
                    is much more scalable than an approach that routes through the server. This is because the
                    client-side can be decoupled from the server meaning that a server is not required to constantly
                    serve the content to a user and can instead horizontally scale and cater for increased demand from
                    users. By accessing an API to receive application data, the front-end client can add additional
                    pages and make modifications to components without requiring change to the functionality and logic
                    behind complex business operations.</li>
                <li><strong>Employs Accessibility practices</strong> - As the front-end is the closest to the user, it
                    is expected that most accessibility practices will be enforced on the visual and behavioral aspects
                    of the interface. By employing good practice such as support for screen readers, options to increase
                    font-size, magnifiers and more, a business can cater for all groups regardless of ability.
                </li>
            </ul>
            <div class="project-feature-container">
                <h3>Login</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/login.png")%>
                alt="Login Page"
                />
                <p>
                    The login page is a simple, intuitive way for users to authenticate and enable persistent login on
                    their device. Users without an account can easily follow the sign-up link to render the register
                    page. Email and password fields contain no client-side validation as the user is expected to know
                    their credentials. The password is hidden with bullet points to secure the input from prying eyes.
                    Included is a shortened footer with the logo, a description, social links, copyright and terms and
                    conditions. To provide responsiveness, the mobile view adjusts the margins and sizes the form to fit
                    the viewport height with the footer just below.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Register</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/register.png")%>
                alt="Register Page"
                />
                <p>
                    The register page is structured like the login page for consistency. It contains several fields
                    required in creating an account with Insight. The key difference is that these fields provide
                    client-side validation that will block the submission of the sign-up button if at least one field is
                    invalid. Invalid fields will display a red cross to signal to the user that their input is invalid
                    and valid fields are displayed with a green tick. Invalid fields that are focused by the user will
                    produce a message explaining what is expected in each field to assist in modifying the input to meet
                    the requirements. To easily log in if a user contains an account, they can use the sign-in link to
                    render the login page. The register page also contains the same footer and responsiveness as the
                    login page.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Footer and FooterFull</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/footer.png")%>
                alt="Footer and FooterFull"
                />
                <p>
                    Within the development of the application, there were two footers for public and protected routes
                    that share most of the information. The difference is the application links provided in the full
                    version which will only be found on routes that expect the user to already be authenticated. This is
                    significant as it means we can improve user experience by providing quick access to areas in the
                    application without needing to scroll back to the top. We can also prevent users from accessing
                    areas of the application without authenticating first by providing a shorter version on public
                    routes.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Loading</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/loading.png")%>
                alt="Loading Snippet"
                />
                <p>
                    Implementing react spinners means we can provide greater user experience by animating and informing
                    users that content is loading. Used alongside progressive loading, an animated spinner is effective
                    in allowing the smooth transition of content in a single-page application where the user can still
                    feel connected and stay informed in the condition of the application.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Dashboard</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/dashboard.png")%>
                alt="Dashboard Page"
                />
                <p>
                    The dashboard page is a centralized location for accessing recommendations for the logged in user
                    that is built from the interactions with the application. When a user first visits the dashboard
                    page, each recommendation section is empty and prompts the user to interact with books and reviews
                    to build a profile for recommendations. Viewing books will influence the books displayed in the view
                    recommendations. Liking and disliking books will influence the books displayed in the like
                    recommendations. Rating books greater than 4 will influence the books displayed in the rating
                    recommendations. The dashboard page also contains a personalized welcome message and a button to
                    create a review to direct users in participating in the community by sharing their thoughts. Like
                    the other pages, the dashboard page is responsive and will structure the content appropriately with
                    the viewport size available.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Navigation</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/navigation.png")%>
                alt="Navigation and Drawer Snippet"
                />
                <p>
                    Navigation in the development of the demonstrated application is catered for across all screen
                    sizes. Desktop sizes will produce the full navbar, iPad and similar sizes will produce a navbar of
                    icons and mobile sizes will produce a navbar with the burger menu. Clicking on the burger menu will
                    cause the navigation drawer to appear with a vertical list of the navigation links as well as the
                    corresponding icons. The search bar stays consistent throughout and links to the books page to
                    produce results of books from the input.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Settings</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/settings.png")%>
                alt="Settings Drawer"
                />
                <p>
                    The settings drawer is a part of the navbar that appears by clicking the settings button. While
                    there are only two accessibility options currently available, this area was built to allow the
                    continuous configuration of the application to cater for more individuals of all abilities. The
                    increase font size option will adjust the font size variables for various elements in the DOM
                    according to the viewport width. Increasing the font size on a desktop will have more of an impact
                    than on a mobile as the availability of space limits how much we can increase the size before
                    disrupting the user experience. Other tools such as a magnifier can be used alongside increased font
                    sizes to solve this issue. The dark mode option will adjust the color variables in the application
                    to include colors that are less harsh and nicer to use in areas with limited light. It provides
                    personalization for the user as well as accessibility for users who have sensitive sight or limited
                    light.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Books</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/books.png")%>
                alt="Books Page"
                />
                <p>
                    The books page includes paginated results from a search value or from the full list of books. A user
                    is able to search for a book by title or category in the navbar and will receive results they can
                    flick through using the pagination buttons explained further in the next section. By clicking on a
                    book card, the application will render the associated book page. The books page also maintains
                    responsiveness by altering the structure of content to match the viewport size.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Pagination</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/pagination.png")%>
                alt="Pagination Snippet"
                />
                <p>
                    Referenced in the previous section, pagination in the application is used in areas where there are
                    many values of interest to be displayed to the user. As it is slower and difficult to read large
                    quantity of results, it was more effective to combine the concepts of single page applications and
                    updating the DOM with using pages and limiting results. Now users can read content and flick through
                    the pages with the arrow buttons. Some areas of pagination implemented include the book list, list
                    of reviews and list of comments.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Create Review</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/createReview.png")%>
                alt="Create Review Page"
                />
                <p>
                    The create review page contains fields and validation for creating a review. It can be accessed via
                    the book page and will autofill the book field or separate from the book page where the user will be
                    required to enter a valid book title to create the review. If the book is not found an error is
                    produced to inform the user to enter a valid book title. The title, body, and rating fields allow
                    the personalization of the review and will contain their own validation rules and explanation
                    messages on focus. Like the register page, the user will not be able to click on the submit button
                    if there is at least one invalid field and fields are made responsive to the viewport size. Clicking
                    the cancel button will return the user to the dashboard or the book page.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Account</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/account.png")%>
                alt="Account Page"
                />
                <p>
                    The account page allows the user to review account information as well as update. Visiting the page
                    will autofill all fields except password fields so the user is able to easily read and modify
                    account details. As with other forms in the application, each has its own validation rules and
                    explanation messages and will prevent updating the account if at least one is invalid. The account
                    page also has a delete account button which will prompt the user to delete their account. More on
                    delete modals will be found in an upcoming section. Responsiveness is also considered on the account
                    page as fields and margins are adjusted by viewport size.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Errors</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/errors.png")%>
                alt="Errors Snippet"
                />
                <p>
                    Errors in the application were developed to inform the user as well as assist in debugging
                    exceptions that occur during runtime. The primary source of error messaging includes the red cross
                    on forms with invalid fields as well as the explanation message that appears when an invalid field
                    is focused. Other areas include messages that appear due to invalid credentials on login, loss of
                    connection to the server, unhandled exceptions on the server and reaching a route that does not
                    exist.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Book</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/book.png")%>
                alt="Book Page"
                />
                <p>
                    The book page displays information relating to a particular book a user wants to view and creates a
                    new view-book event to be processed and cause alteration to the view recommendations. Within the
                    displayed details a user can identify the book average rating, thumbnail, title, subtitle,
                    description, ISBN, authors, categories, published year, and number of pages. They can also see a
                    paginated list of reviews relating to that book which informs the user of the review title, when the
                    review was created and updated, who created the review, the rating given by the creator and a short
                    abstract from the review body. There are also like, and dislike buttons provided on the book page
                    which persist on refresh and create like and unlike events to be processed and alter the like
                    recommendations. Performing several interactions such as viewing and liking multiple books with
                    similar categories will cause the dashboard to update to match the new profile with recommendations
                    created to suit the user.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Links and Buttons</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/linksButtons.png")%>
                alt="Links and Buttons Snippet"
                />
                <p>
                    Links and Buttons in the application follow the same interactive principles. Links will idle with a
                    normal font size and white color and will transition on hover to a slightly larger scale and change
                    to a secondary color to provide visual feedback to the user. Buttons will idle with a normal size
                    and purple, white color and will transition to a slightly larger scale and lower opacity on hover.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Update Review</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/updateReview.png")%>
                alt="Update Review Page"
                />
                <p>
                    Modification of reviews can be made on the update review page which contains the populated fields of
                    existing review detail for easy alteration. The book is kept the same and is unmodifiable as the
                    application expects updates to be made on the title, body, or rating and not the book it is on.
                    Validation rules exist on each field and negate submission if at least one field is invalid.
                    Clicking the cancel button will return the user back to the review page. The page is made responsive
                    by adjusting fields and margins to fit the viewport size.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Comments</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/comments.png")%>
                alt="Comments Snippet"
                />
                <p>
                    Comments exist on review pages and allow users to create, modify and delete discussions. Clicking
                    the create comment button will produce a popup field for the user to enter their input and submit to
                    add to the existing discussion. If the user owns a comment, they will be able to access the update
                    and delete buttons. The update button will produce a field like creating a comment and will replace
                    the comment body with the entered input. Clicking the delete button will open a delete modal for
                    deleting the comment. Clicking cancel or the cross will cancel any request to create, update or
                    delete a comment. Comments will display the username of the user that created the comment, when the
                    comment was created, when it was updated and the body of the comment.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Review</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/review.png")%>
                alt="Review Page"
                />
                <p>
                    The review page provides details such as the review title, rating, username of the creator, date
                    when it was created, date when it was updated and the body. It also shows a small image of the book
                    the review is discussing. Clicking the update review button will render the update review page.
                    Clicking the delete review button will produce a delete review modal. Review pages also contain
                    comments where users can express their own opinions and get on the discussion. These are paginated
                    so the user can flick through the history of comments made on the review. Elements in the page are
                    also structured so that they respond to the viewport size for responsiveness.
                </p>
            </div>
            <div class="project-feature-container">
                <h3>Delete Modals</h3>
                <img src=<%=require("../../assets/images/projects/book-app-client/deleteModals.png")%>
                alt="Delete Modals Snippet"
                />
                <p>
                    The delete modal is a technique used in the development of the application that prompts the user for
                    the deletion of a specific application entity before the operation is completed. This ensures
                    mistakes by clicking the delete button do not happen without the ownerâ€™s full consent. Reviews and
                    comments have the capability for owners to delete them by clicking on their associated delete
                    buttons and the modal with a backdrop will appear with the prompt after to this. Clicking cancel or
                    the backdrop will return to the page and delete will do the same for deleting a comment and will
                    render the dashboard for a review.
                </p>
            </div>
        </section>
        <section>
            <h2>Implementation</h2>
            <div>
                <h3>Refresh</h3>
                <figure>
                    <pre>
                        <code>
const useRefreshToken = () => {
    const { setAuth } = useAuth();
    
    // Obtain access token form refresh endpoint which checks for a refresh cookie
    const refresh = async () => {
        const response = await axios.get("/auth/refresh", {
        withCredentials: true,
        });
        // Set auth context to include the new access token and email
        setAuth((prev) => {
        return {
            ...prev,
            email: response.data.email,
            accessToken: response.data.accessToken,
        };
        });
        return response.data.accessToken;
    };
    
    return refresh;
    };
                        </code>
                    </pre>
                </figure>
                <p>
                    When the access token expires, the Front-End Client will intercept the error from the response and
                    will run the useRefreshToken hook to obtain a new access token before retrying the operation. The
                    hook contains the Back-End API Refresh endpoint and the request sent includes the HTTP-only cookie
                    containing the Refresh Token. A successful response will overwrite the Auth context with the new
                    access token and the user's email.
                </p>
            </div>
            <div>
                <h3>Authentication</h3>
                <figure>
                    <pre>
                        <code>
const useLogout = () => {
    const { setAuth } = useAuth();
    
    // Clear the auth context and reach the logout endpoint to delete the cookie
    const logout = async () => {
        setAuth({});
        try {
        await axios.delete("/auth/logout", {
            withCredentials: true,
        });
        } catch (err) {
        console.error(err);
        }
    };
    
    return logout;
    };
                        </code>
                    </pre>
                </figure>
                <p>
                    Logging out, the component receives the refresh cookie and obtains the refresh token to check to see
                    if a user with that token is currently logged in. If not, the cookie is deleted. If so, the cookie
                    is deleted, and the refresh token stored in the database is cleared. On the front-end clientâ€™s side,
                    the logout hook is used to clear the auth context, access the logout endpoint on the back-end client
                    and render the login page.
                </p>
            </div>
            <div>
                <h3>Client-Side Routing</h3>
                <figure>
                    <pre>
                        <code>
function App() {
    return (
        &lt;Routes&gt;
        &lt;Route path=&quot;/&quot; element={&lt;Layout /&gt;}&gt;
            {/* public routes */}
            &lt;Route path=&quot;login&quot; element={&lt;Login /&gt;} /&gt;
            &lt;Route path=&quot;register&quot; element={&lt;Register /&gt;} /&gt;
            &lt;Route path=&quot;unauthorized&quot; element={&lt;Unauthorized /&gt;} /&gt;
    
            {/* protected routes */}
            &lt;Route element={&lt;PersistLogin /&gt;}&gt;
            &lt;Route element={&lt;RequireAuth /&gt;}&gt;
                &lt;Route path=&quot;/&quot; element={&lt;Dashboard /&gt;} /&gt;
                &lt;Route path=&quot;account&quot; element={&lt;Account /&gt;} /&gt;
                &lt;Route path=&quot;book/:bookId&quot; element={&lt;Book /&gt;} /&gt;
                &lt;Route path=&quot;books&quot; element={&lt;Books /&gt;} /&gt;
                &lt;Route path=&quot;books/:search&quot; element={&lt;Books /&gt;} /&gt;
                &lt;Route path=&quot;review/:reviewId&quot; element={&lt;Review /&gt;} /&gt;
                &lt;Route path=&quot;review/:reviewId/update&quot; element={&lt;UpdateReview /&gt;} /&gt;
                &lt;Route path=&quot;reviews/create&quot; element={&lt;CreateReview /&gt;} /&gt;
            &lt;/Route&gt;
            &lt;/Route&gt;
    
            {/* catch all */}
            &lt;Route path=&quot;*&quot; element={&lt;Missing /&gt;} /&gt;
        &lt;/Route&gt;
        &lt;/Routes&gt;
    );
    }
                        </code>
                    </pre>
                </figure>
                <p>
                    Client-Side routing in the application is handled through react-router where routes are defined in
                    an App component. Routes contain a path that if visited, will cause the component in the element
                    attribute to be rendered. The hierarchy of routes matters in the sense that child routes of
                    PersistLogin will allow the safe refresh of the page, and child routes of RequireAuth will check if
                    the user is authenticated before rendering protected route components. Routes not a child of
                    RequireAuth will be made public which makes sense for the login and register pages. Creating a route
                    with an asterisk will capture all undefined paths and will render the missing component that informs
                    the user that the requested page does not exist. Route parameters like the back-end API can be used
                    on the client-side to produce dynamic results. The Book component, for example, will check for the
                    parameter value during mounting and will make requests to the back-end API for information relating
                    to a book with the provided ID. Routes that render the same component such as the Books routes are
                    useful for providing paginated books of the entire library or from a search value.
                </p>
            </div>
            <div>
                <h3>Refresh</h3>
                <figure>
                    <pre>
                        <code>
const PersistLogin = () =&gt; {
    const [isLoading, setIsLoading] = useState(true);
    const refresh = useRefreshToken();
    const { auth, persist } = useAuth();
    
    // Obtain access token when required and persist enabled
    useEffect(() =&gt; {
        let isMounted = true;
        const verifyRefreshToken = async () =&gt; {
        try {
            // Get access token
            await refresh();
        } catch (err) {
            console.error(err);
        } finally {
            // Not loading when finished getting new token
            isMounted &amp;&amp; setIsLoading(false);
        }
        };
    
        // Get new token if do not currently have one and persistent login is enabled
        !auth?.accessToken &amp;&amp; persist ? verifyRefreshToken() : setIsLoading(false);
    
        return () =&gt; (isMounted = false);
    
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    
    return (
        &lt;&gt;
        {!persist ? (
            &lt;Outlet /&gt;
        ) : isLoading ? (
            &lt;div className=&quot;loadingContainer&quot;&gt;
            &lt;ClipLoader
                color=&quot;var(--color-main)&quot;
                loading={isLoading}
                size={150}
                aria-label=&quot;Loading Spinner&quot;
            /&gt;
            &lt;/div&gt;
        ) : (
            &lt;Outlet /&gt;
        )}
        &lt;/&gt;
    );
    };


// Toggle whether to enable persistant login
const togglePersist = () => {
    setPersist((prev) => !prev);
};

// Store persist in local storage
useEffect(() => {
    localStorage.setItem("persist", persist);
}, [persist]);
                        </code>
                    </pre>
                </figure>
                <p>
                    Persistent Login in the application allows the user to refresh and reobtain the required auth state
                    without reauthentication. The PersistLogin component on being mounted will display a loading spinner
                    to the user and will run the refresh hook to obtain the userâ€™s email and access token and will have
                    these assigned to the auth context. After running the hook, the application is set to not be loading
                    and if the refresh was successful, the user can continue where they left off in the application or
                    being unsuccessful, redirect to authenticate through RequireAuth. The persistent login feature can
                    be toggled on the login page by choosing to trust the device. As this choice is specific to the
                    instance on a particular device, the boolean value is kept within local storage and poses no risk.
                </p>
            </div>
            <div>
                <h3>Auth Context and Provider</h3>
                <figure>
                    <pre>
                        <code>
const AuthContext = createContext({});

export const AuthProvider = ({ children }) =&gt; {
    const [auth, setAuth] = useState({});
    const [persist, setPersist] = useState(
    JSON.parse(localStorage.getItem(&quot;persist&quot;)) || false
    );

    // Pass auth context to each child component
    return (
    &lt;AuthContext.Provider value={{ auth, setAuth, persist, setPersist }}&gt;
        {children}
    &lt;/AuthContext.Provider&gt;
    );
};


try {
    // Login
    const response = await axios.post(
      LOGIN_URL,
      JSON.stringify({ email, password: pwd }),
      {
        headers: { "Content-Type": "application/json" },
        withCredentials: true,
      }
    );
    // Obtain access token and cookie. Token and other important information stored securely in auth context
    const accessToken = response?.data?.accessToken;
    setAuth({
      email,
      pwd,
      accessToken,
      fontIncrease: false,
      darkMode: false,
    });
    setEmail("");
    setPwd("");
    // Navigate to previous location if exists (which could have blocked entry due to the need to reauthenticate) or dashboard
    navigate(from, { replace: true });
                        </code>
                    </pre>
                </figure>
                <p>
                    The auth context is the secure environment in react that provides access to data to authenticate a
                    user in child components. The AuthProvider is the component that will pass the auth context and
                    persist boolean value to components nested in the route hierarchy. When a user logs in to the
                    application, they have their credentials sent in a request from axios to the login endpoint on the
                    back-end API. If valid, the response will contain an access token that is used alongside other user
                    and accessibility data to set the auth context.
                </p>
            </div>
            <div>
                <h3>RequireAuth</h3>
                <figure>
                    <pre>
                        <code>
const RequireAuth = () =&gt; {
    const { auth } = useAuth();
    const location = useLocation();
    
    // If user exists in context then allow entry. If access token exists and user doesn't, then token is deemed invalid. No token or user will require re-authenticating
    return auth?.email ? (
        &lt;Outlet /&gt;
    ) : auth?.accessToken ? (
        &lt;Navigate to=&quot;/unauthorized&quot; state={{ from: location }} replace /&gt;
    ) : (
        &lt;Navigate to=&quot;/login&quot; state={{ from: location }} replace /&gt;
    );
    };
                        </code>
                    </pre>
                </figure>
                <p>
                    The RequireAuth component is used to check if the user is authenticated when trying to access
                    protected, child routes. It contains a ternary statement for checking if the userâ€™s email exists in
                    the context and allows entry if it is. If not, it checks if an access token exists. If it does, then
                    it is deemed to be invalid, and the unauthorized component is rendered. If not, the user is prompted
                    to reauthenticate on the login page.
                </p>
            </div>
            <div>
                <h3>Axios and Interceptors</h3>
                <figure>
                    <pre>
                        <code>
const useAxiosPrivate = () =&gt; {
    const refresh = useRefreshToken();
    const { auth } = useAuth();
    
    useEffect(() =&gt; {
        // Request interceptor. Assign authorization header if doesn't currently exist.
        const requestIntercept = axiosPrivate.interceptors.request.use(
        (config) =&gt; {
            if (!config.headers[&quot;Authorization&quot;]) {
            config.headers[&quot;Authorization&quot;] = `Bearer ${auth?.accessToken}`;
            }
            return config;
        },
        (error) =&gt; Promise.reject(error)
        );
    
        // Response interceptor. Upon first failure as access token is now invalid, obtain new refresh token and try again.
        const responseIntercept = axiosPrivate.interceptors.response.use(
        (response) =&gt; response,
        async (error) =&gt; {
            const prevRequest = error?.config;
            if (error?.response?.status === 403 &amp;&amp; !prevRequest?.sent) {
            prevRequest.sent = true;
            const newAccessToken = await refresh();
            prevRequest.headers[&quot;Authorization&quot;] = `Bearer ${newAccessToken}`;
            return axiosPrivate(prevRequest);
            }
            return Promise.reject(error);
        }
        );
    
        return () =&gt; {
        axiosPrivate.interceptors.response.eject(responseIntercept);
        axiosPrivate.interceptors.response.eject(requestIntercept);
        };
    }, [auth, refresh]);
    
    return axiosPrivate;
    };


// Make requests without Authentication
export default axios.create({
  baseURL: BASE_URL,
});

// Make requests with Authentication
export const axiosPrivate = axios.create({
  baseURL: BASE_URL,
  headers: { "Content-Type": "application/json" },
  withCredentials: true,
});
                        </code>
                    </pre>
                </figure>
                <p>
                    Axios is the library used for creating requests to the back-end API and provides additional benefits
                    compared to native Fetch such as removing the need to convert the response to JSON. Another great
                    benefit and use case for axios is the ability to apply interceptors. Similar to middleware, these
                    functions configure the request before being sent to the back-end API and the response before being
                    received by application components. The request interceptor will check if the Authorization header
                    exists and will set it with the access token if not. The response interceptor will check if an
                    unauthorized error is returned from the initial request sent and will run the refresh hook to obtain
                    a new token before trying the request again. Failing again will cause an error and will require the
                    user to reauthenticate. Note that axios is used to make requests to both public and protected
                    routes. We define the axios instance with the base url of the back-end API for just making public
                    requests, and we define axiosPrivate with the base url, headers, and credentials for attaching the
                    refresh cookie for requests to protected routes.
                </p>
            </div>
            <div>
                <h3>Increasing Font Size and Dark Mode</h3>
                <figure>
                    <pre>
                        <code>
// When the window is resized and accessbility font option is selected, adjust the size variables
useEffect(() => {
    const root = document.querySelector(":root");
    const width = window.innerWidth;

    if (auth.fontIncrease && width > 500) {
    root.style.setProperty("--text-size", "22px");
    root.style.setProperty("--h1-size", "2.5em");
    root.style.setProperty("--h2-size", "2em");
    root.style.setProperty("--h3-size", "1.5em");
    root.style.setProperty("--grid-size", "300px");
    } else if (auth.fontIncrease && width <= 500) {
    root.style.setProperty("--text-size", "18px");
    root.style.setProperty("--h1-size", "2em");
    root.style.setProperty("--h2-size", "1.5em");
    root.style.setProperty("--h3-size", "1em");
    root.style.setProperty("--grid-size", "300px");
    } else if (!auth.fontIncrease && width > 500) {
    root.style.setProperty("--text-size", "18px");
    root.style.setProperty("--h1-size", "2em");
    root.style.setProperty("--h2-size", "1.5em");
    root.style.setProperty("--h3-size", "1em");
    root.style.setProperty("--grid-size", "280px");
    } else if (!auth.fontIncrease && width <= 500) {
    root.style.setProperty("--text-size", "16px");
    root.style.setProperty("--h1-size", "2em");
    root.style.setProperty("--h2-size", "1.5em");
    root.style.setProperty("--h3-size", "1em");
    root.style.setProperty("--grid-size", "280px");
    }
}, [auth, width]);

// When the darkmode accessibility option is selected, adjust the color variables
useEffect(() => {
    const root = document.querySelector(":root");
    if (auth.darkMode) {
    root.style.setProperty("--color-main", "#282872");
    root.style.setProperty("--color-secondary", "#0d0d28");
    } else {
    root.style.setProperty("--color-main", "rgb(83, 83, 206)");
    root.style.setProperty("--color-secondary", "#282872");
    }
}, [auth]);
                        </code>
                    </pre>
                </figure>
                <p>
                    Accessibility options such as increasing font size and dark mode were included as examples of good
                    accessibility and inclusion of all groups in the demonstrated application. Changes to the
                    application to become more accessible are reflected by configurations made to the root variables.
                    To increase the font size, the user will tick the checkbox in the settings and the useEffect will
                    run due to changes to the auth context or width as dependencies. Within this useEffect, the current
                    width of the viewport will be checked and will adjust the rate of increase depending on the width of
                    the viewport. The greatest increase will be with the option selected and the viewport greater than
                    500px, then it will be a slightly smaller increase when less than 500px. Without the option
                    selected, the font size will be normal when the width is greater than 500px then slightly reduced
                    when less than 500px.
                    To enable dark mode, the user will tick the checkbox in the settings and the useEffect will run due
                    to changes to the auth context as a dependency. As a result, the useEffect will toggle the colors
                    stored in the root variables and will cause the application to change to reflect these new colors in
                    its components.

                </p>
            </div>
        </section>
        <section>
            <div class="github-repo-container">
                <div>
                    <a href="https://github.com/KyleKeeneWelch/BookAppClient" target="_blank"><i
                            class="fa-brands fa-github icon" aria-hidden="true"></i></a>
                    <a href="https://github.com/KyleKeeneWelch/BookAppClient" target="_blank">Kyle Keene-Welch |
                        Front-End Client</a>
                </div>
            </div>
            <div>
                <h2>Want to know more?</h2>
                <p class="center">Get in contact by visiting the <a href="contact.html">Contact Page</a> or
                    alternatively emailing <a href="mailto:kylekeene.welch@gmail.com">kylekeene.welch@gmail.com</a></p>
            </div>
        </section>
        <footer>
            <p>Kyle Keene-Welch Â© 2024</p>
            <a href="https://github.com/KyleKeeneWelch"><i class="fa-brands fa-github icon" aria-hidden="true"></i></a>
            <a href="mailto:kylekeene.welch@gmail.com">kylekeene.welch@gmail.com</a>
        </footer>
    </main>
</body>

</html>